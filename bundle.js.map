{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://mastermind/./src/combination.ts","webpack://mastermind/./src/time.ts","webpack://mastermind/./src/game-state.ts","webpack://mastermind/./src/dom-manipulation.ts","webpack://mastermind/./src/listeners.ts","webpack://mastermind/./src/record.ts","webpack://mastermind/./src/index.ts"],"sourcesContent":["/**\n * @param {string[]} colors the available colors of the game\n * @param {number} nbPossibilities the number of possibilities by line choose by the player\n * @param {boolean} duplicate boolean that indicate if there are duplicate colors in the combination\n * @returns {string[]} a combination of X colors, where X is the number of possibilities by line\n */\nexport function generateCombination(\n  colors: string[],\n  nbPossibilities: number,\n  duplicate: boolean,\n) {\n  if (!duplicate && nbPossibilities > colors.length) {\n    throw new Error('Impossible to create a combination');\n  }\n\n  if (duplicate === false) {\n    const shuffleColors = colors.sort(() => 0.5 - Math.random());\n\n    return Array.from(new Set(shuffleColors)).slice(0, nbPossibilities);\n  }\n\n  return [...Array(nbPossibilities)].map(\n    () => colors[Math.floor(Math.random() * colors.length)],\n  );\n}\n\n/**\n *\n * @param {NodeListOf<HTMLDivElement>} currentTargets the targets which contains the current combination\n * @param {string[]} colors the available colors of the game\n * @returns {string[]} an array containing the actual combination of colors or an error if the combination is not complete\n */\nexport function getCurrentCombination(\n  currentTargets: NodeListOf<HTMLDivElement>,\n  colors: string[],\n) {\n  const combination: string[] = [];\n\n  for (let i = 0; i < currentTargets.length; i++) {\n    const currentTargetPiece = currentTargets[i].querySelector(\n      'div.target-piece',\n    ) as HTMLDivElement;\n\n    // remove all alert class\n    currentTargetPiece.classList.remove('alert');\n\n    const color = currentTargetPiece.className\n      .split(' ')\n      .filter((e) => colors.includes(e))[0];\n\n    if (!color) {\n      // Hack to make the animation restart. See: https://stackoverflow.com/questions/16050914/css-animation-doesnt-restart-when-resetting-class\n      setTimeout(() => {\n        currentTargetPiece.classList.add('alert');\n      }, 1);\n    } else {\n      combination.push(color);\n    }\n  }\n\n  if (combination.length !== currentTargets.length) {\n    throw new Error('Combination is not complete');\n  }\n\n  return combination;\n}\n\n/**\n *\n * @param {string[]} currentCombination the current combination of colors\n * @param {string[]} finalCombination the combination of colors to refer to\n * @returns {{goodPlacement : number, wrongPlacement:number}} an object containing the number of goodEmplament and wrongEmplacement of the current combination\n */\nexport function getCombinationPlacement(\n  currentCombination: string[],\n  finalCombination: string[],\n): { goodPlacement: number; wrongPlacement: number } {\n  const goodPlacement: string[] = [];\n  let wrongPlacement: string[] = [];\n\n  currentCombination.forEach((color, index) => {\n    if (finalCombination[index] === color) {\n      goodPlacement.push(color);\n\n      /**\n       * remove the color from the wrong emplacement if we already\n       * have all the good placement. This verification allow to delete\n       * the duplicates indicators.\n       * see https://github.com/RomainGuarinoni/mastermind/issues/8\n       */\n      if (\n        goodPlacement.filter((e) => e === color).length ===\n        getColorApparition(finalCombination, color)\n      ) {\n        wrongPlacement = wrongPlacement.filter((e) => e !== color);\n      }\n\n      return;\n    }\n\n    if (\n      finalCombination.includes(color) &&\n      [...goodPlacement, ...wrongPlacement].filter((e) => e === color).length <\n        getColorApparition(finalCombination, color)\n    ) {\n      wrongPlacement.push(color);\n      return;\n    }\n  });\n\n  return {\n    goodPlacement: goodPlacement.length,\n    wrongPlacement: wrongPlacement.length,\n  };\n}\n\n/**\n *\n * @param {string[]} combination a combination of colors\n * @param {string} color the available colors of the game\n * @returns {number} the number of time a color appear in a combination\n */\nexport function getColorApparition(combination: string[], color: string) {\n  return combination.filter((e) => e === color).length;\n}\n\n/**\n * @description Return an array with only the number of colors wanted\n * @param colors the initial array of colors\n * @param nbColors number of colors wanted by the player\n */\nexport function getAvailableColors(colors: string[], nbColors: number) {\n  const shuffleArray = colors.sort(() => 0.5 - Math.random());\n  return shuffleArray.slice(0, nbColors);\n}\n","export type Time = {\n  milliseconds: number;\n  seconds: number;\n  minutes: number;\n  hours: number;\n};\n\n/**\n *\n * @param {Date} runStart the date start of the run\n * @param {Date} runEnd the date end of the run\n * @returns Return the number of milliseconds the run took\n */\nexport function getDateDifference(runStart: Date, runEnd: Date): number {\n  if (runEnd < runStart) {\n    throw new Error('runStart should be before runEnd');\n  }\n\n  return runEnd.getTime() - runStart.getTime();\n}\n\n/**\n *\n * @param {number} duration A duration in ms\n * @returns an object containing the number of ms,s,m,h\n */\nexport function convertMsToTime(duration: number): Time {\n  const milliseconds = Math.floor(duration % 1000),\n    seconds = Math.floor((duration / 1000) % 60),\n    minutes = Math.floor((duration / (1000 * 60)) % 60),\n    hours = Math.floor((duration / (1000 * 60 * 60)) % 24);\n  return { milliseconds, seconds, minutes, hours };\n}\n\nexport function convertTimeToMs(time: Partial<Time>) {\n  let result = 0;\n\n  if (time.hours) result += time.hours * 60 * 60 * 1000;\n  if (time.minutes) result += time.minutes * 60 * 1000;\n  if (time.seconds) result += time.seconds * 1000;\n  if (time.milliseconds) result += time.milliseconds;\n  return result;\n}\n\nexport function convertTimeToString(time: Time) {\n  let result = '';\n  if (time.hours) {\n    result += `${time.hours}h `;\n  }\n  if (time.minutes) {\n    result += `${time.minutes}m `;\n  }\n  if (time.seconds) {\n    result += `${time.seconds}s `;\n  }\n  if (time.milliseconds) {\n    result += `${time.milliseconds}ms `;\n  }\n  if (result == '') {\n    result += '0ms ';\n  }\n  return result;\n}\n","enum GameState {\n  running,\n  win,\n  lose,\n}\n\nexport default GameState;\n","import { convertMsToTime, convertTimeToString } from './time';\nimport { Run } from './record';\nimport GameState from './game-state';\n\nexport enum Indicators {\n  'white',\n  'red',\n}\n\ntype Display = 'block' | 'flex' | 'none' | 'inline';\n\n/**\n * @description Add a new line to the game container\n * @param {number} index the index for the line id\n * @param {HTMLDivElement} gameContainer the game container element wich contains the lines\n * @param {number} nbPossibilities the number of possibilities by line\n */\nexport function addNewGameLine(\n  round: number,\n  gameContainer: HTMLDivElement,\n  nbPossibilities: number,\n) {\n  const line = document.createElement('div');\n  line.classList.add('line');\n  line.id = `line-${round}`;\n\n  const redIndicatorContainer = document.createElement('div');\n  redIndicatorContainer.classList.add('red-indicator-container');\n\n  const whiteIndicatorContainer = document.createElement('div');\n  whiteIndicatorContainer.classList.add('white-indicator-container');\n\n  const targetContainer = document.createElement('div');\n  targetContainer.classList.add('targets-container');\n\n  for (let i = 0; i < nbPossibilities; i++) {\n    const target = document.createElement('div');\n    target.classList.add('target');\n\n    const targetPiece = document.createElement('div');\n    targetPiece.classList.add('target-piece');\n\n    target.appendChild(targetPiece);\n    targetContainer.appendChild(target);\n  }\n\n  whiteIndicatorContainer.style.width = `${nbPossibilities * 30}px`;\n  redIndicatorContainer.style.width = `${nbPossibilities * 30}px`;\n\n  line.appendChild(redIndicatorContainer);\n  line.appendChild(targetContainer);\n  line.appendChild(whiteIndicatorContainer);\n\n  gameContainer.appendChild(line);\n}\n\n/**\n * @description Add indicators to the game\n * @param {Indicators} type the type of indicators\n * @param {HTMLDivElement} container the container where to put indicators\n * @param {number} number the number of indicators to add\n */\nexport function addIndicators(\n  type: Indicators,\n  container: HTMLDivElement,\n  number: number,\n) {\n  for (let i = 0; i < number; i++) {\n    const indicator = document.createElement('div');\n\n    switch (type) {\n      case Indicators.red:\n        indicator.classList.add('red-indicator');\n        break;\n      case Indicators.white:\n        indicator.classList.add('white-indicator');\n        break;\n    }\n\n    container.appendChild(indicator);\n  }\n}\n\n/**\n * @description change the display of a specify piece\n * @param {string} color the color of the piece\n * @param {Display} display the style of display to apply\n */\nexport function changePieceDisplay(color: string, display: Display) {\n  const piece = document.getElementById(`${color}-piece`) as HTMLDivElement;\n  piece.style.display = display;\n}\n\n/**\n * @description Pick the colors available and make disappear the others\n * @param {string[]} colors an array of all the colors\n * @param {string[]} finalColors an array of wanted colors\n */\nexport function hideUnwantedColor(colors: string[], finalColors: string[]) {\n  colors.forEach((color) => {\n    if (finalColors.includes(color)) {\n      changePieceDisplay(color, 'block');\n    } else {\n      changePieceDisplay(color, 'none');\n    }\n  });\n}\n\n/**\n *\n * @param {number} round the current round index needed to find DOM elements\n * @returns {{targets:NodeListOf<HTMLDivElement>,\n * redIndicatorsContainer:HTMLDivElement,\n * whiteIndicatorsContainer:HTMLDivElement}}  An object containing the DOM elements of the game\n */\nexport function getGameDomElements(round: number) {\n  const line = document.getElementById(`line-${round}`);\n\n  if (!line) {\n    throw new Error('Line does not exist');\n  }\n\n  const targets = line.querySelectorAll(\n    `div.targets-container > div.target`,\n  ) as NodeListOf<HTMLDivElement>;\n  const redIndicatorsContainer = line.querySelector(\n    'div.red-indicator-container',\n  ) as HTMLDivElement;\n  const whiteIndicatorsContainer = line.querySelector(\n    'div.white-indicator-container',\n  ) as HTMLDivElement;\n\n  return {\n    targets,\n    redIndicatorsContainer,\n    whiteIndicatorsContainer,\n  };\n}\n\n/**\n * @description Update the value and the color of the tooltip when we hover the verify button\n * @param {HTMLDivElement} tooltip the DOM tooltip wich contains a <p> with a <span> inside\n * @param {number} currentRound The current round of the game\n * @param {number} nbTurns The total of turn possible in the current run\n */\nexport function updateTooltip(\n  tooltip: HTMLDivElement,\n  currentRound: number,\n  nbTurns: number,\n) {\n  const span = tooltip.querySelector('span');\n\n  const roundLeft = nbTurns + 1 - currentRound;\n\n  if (!span) {\n    throw new Error('No span found in the tooltip');\n  }\n\n  span.innerHTML = `${roundLeft}`;\n\n  if (roundLeft <= Math.floor(nbTurns / 3)) {\n    span.style.color = 'red';\n    return;\n  }\n\n  if (roundLeft <= Math.floor(nbTurns / 3) * 2) {\n    span.style.color = 'orange';\n    return;\n  }\n\n  span.style.color = 'green';\n}\n/**\n *\n * @returns {number} the index of the last game line\n */\nexport function getCurrentNumbersOfLine(): number {\n  return document.getElementsByClassName('line').length;\n}\n\n/**\n * @description Change the content of the verify button\n * @param {HTMLButtonElement} verifyButton\n * @param {'Verify' | 'result'} content\n */\nexport function changeVerifyContent(\n  verifyButton: HTMLButtonElement,\n  gameState: GameState,\n) {\n  if (gameState === GameState.running) {\n    verifyButton.innerHTML = 'Vérifier';\n  } else {\n    verifyButton.innerHTML = 'Voir le résultat';\n  }\n}\n\n/**\n * @description Add to the p pass in param the description of the previousRecord and the comparaison to the currentRun.\n * The useCase of this function is to be called when the user loose a game or win a game without beating his record\n * and the win / loose popUp has to show what is the current record in this category\n * @param p The p element to add the record description\n * @param record The record of the category\n * @param run The current run in the same category\n * @param endGameStatus The game status, if set to win, we display the diff of time between run and record, otherwise not\n */\nexport function displayPreviousRecord(\n  p: HTMLParagraphElement,\n  record: Run | null,\n  run: Run,\n  gameState: GameState,\n) {\n  let text = '';\n  if (!record) {\n    text = \"Vous n'avez pas encore de record dans cette catégorie.\";\n  } else {\n    const timeString = convertTimeToString(convertMsToTime(record.time));\n    const runDiff = convertTimeToString(\n      convertMsToTime(run.time - record.time),\n    );\n\n    text = `Votre meilleur score dans cette catégorie est de :<br><strong>${timeString}</strong> effectué le <strong>${record.date.toLocaleDateString()}</strong> à <strong>${record.date.toLocaleTimeString()}</strong><br>`;\n\n    if (gameState == GameState.win) {\n      text += `Vous avez mis <strong style=\"color:var(--red)\">${runDiff}</strong> de plus`;\n    }\n  }\n\n  p.innerHTML = text;\n}\n\n/**\n * @description Add to the p pass in param the description of the new Record that the user just made in the current Run.\n * If there is a previous record, it will show the differencee.\n * @param p The p element to add the record description\n * @param newRecord The new record of the category, the current run\n * @param previousRecord The previous recorrd of this category\n *\n */\nexport function displayNewRecord(\n  p: HTMLParagraphElement,\n  newRecord: Run,\n  previousRecord: Run | null,\n) {\n  let text =\n    'Bravo, vous venez de créer un nouveau record pour cette catégorie !<br>';\n\n  if (previousRecord) {\n    const timeDiff = convertTimeToString(\n      convertMsToTime(previousRecord.time - newRecord.time),\n    );\n    text += `Vous avez mis <strong style=\"color:var(--green)\">${timeDiff}</strong> de moins que votre précédent record`;\n  }\n\n  p.innerHTML = text;\n}\n","import {\n  getCurrentNumbersOfLine,\n  getGameDomElements,\n} from './dom-manipulation';\n\n/**\n * @description Set the piece data transfer to its color\n * @param {DragEvent} e the drag event of the listener\n */\nfunction setPieceDragData(e: DragEvent) {\n  const color = (e.target as Element).id.split('-')[0];\n  e.dataTransfer?.setData('text/plain', color);\n  (e.dataTransfer as DataTransfer).effectAllowed = 'move';\n}\n\n/**\n * @description listener function on drag over event\n * @param {Event} e the event of the listener\n */\nfunction setTargetDropEffect(e: Event) {\n  e.preventDefault();\n  ((e as DragEvent).dataTransfer as DataTransfer).dropEffect = 'move';\n}\n\n/**\n * @description get the color of the drag item and change the target piece\n *  background to this color\n * @param {DragEvent} e the drag event of the listener\n * @param {string[]} colors the colors available in the game\n */\nfunction setTargetBackgroundColor(e: DragEvent, colors: string[]) {\n  e.preventDefault();\n  const color = (e.dataTransfer as DataTransfer).getData('text/plain');\n  const targetPiece = (e.currentTarget as Element).querySelector(\n    'div.target-piece',\n  ) as HTMLDivElement;\n\n  targetPiece.classList.remove(...colors);\n  targetPiece.classList.add(color, 'current-target-piece');\n}\n\n/**\n * @description remove the color of a target piece if the target is clicked\n * @param {Event} e\n */\nfunction removeColorFromTarget(e: Event) {\n  const targetPiece = (e.currentTarget as Element).querySelector(\n    'div.target-piece',\n  ) as HTMLDivElement;\n\n  targetPiece.classList.remove(...targetPiece.classList.value.split(' '));\n  targetPiece.classList.add('target-piece');\n}\n\n/**\n * @description Add the drag event listeners of the targets\n * @param {NodeListOf<HTMLDivElement>} targets the targets to add eventListeners\n * @param {string[]} colors the colors available in the game\n */\nexport function addTargetListener(\n  targets: NodeListOf<HTMLDivElement>,\n  colors: string[],\n) {\n  for (let i = 0; i < targets.length; i++) {\n    targets[i].addEventListener('dragover', setTargetDropEffect, true);\n\n    targets[i].addEventListener('drop', (e) =>\n      setTargetBackgroundColor(e as DragEvent, colors),\n    ),\n      true;\n\n    targets[i].addEventListener('mousedown', removeColorFromTarget);\n  }\n}\n\n/**\n * @description Remove the drag event listener of the targets\n * @param {NodeListOf<HTMLDivElement>} target The targets to remove eventListeners\n */\nexport function removeTargetListener(targets: NodeListOf<HTMLDivElement>) {\n  for (let i = 0; i < targets.length; i++) {\n    targets[i].removeEventListener('dragover', setTargetDropEffect, true);\n    targets[i].removeEventListener('mousedown', removeColorFromTarget);\n    targets[i].classList.remove('current-target');\n  }\n}\n\n/**\n * @description Add dragStart events on game pieces\n * @param {Array<HTMLDivElement>} pieces All the pieces of the game\n */\nexport function setDragListenerOnPieces(pieces: Array<HTMLDivElement>) {\n  window.addEventListener('DOMContentLoaded', () => {\n    pieces.forEach((piece) =>\n      piece.addEventListener('dragstart', setPieceDragData),\n    );\n  });\n}\n\n/**\n *\n * @param {MouseEvent} e  The event thats created when tu user click on a reducePopup button\n */\nfunction reduceButtonPopUp(e: MouseEvent) {\n  // Remove the target listeners of the last line\n  const { targets } = getGameDomElements(getCurrentNumbersOfLine());\n  removeTargetListener(targets);\n\n  const popUp = (e.target as HTMLButtonElement).closest(\n    '.popup',\n  ) as HTMLDivElement;\n  popUp.style.display = 'none';\n}\n\n/**\n * @description Add a listener to reduce the popUp when it's reduce button is clicked\n * @param {HTMLCollectionOf<HTMLButtonElement>} buttons The list of all the reducePopUp button\n */\nexport function addReducePopUpListener(\n  buttons: HTMLCollectionOf<HTMLButtonElement>,\n) {\n  for (let i = 0; i < buttons.length; i++) {\n    buttons[i].addEventListener('click', reduceButtonPopUp);\n  }\n}\n\n/**\n * @description Add a callback to the submit event of a form\n * @param form The form\n * @param action  the callback\n */\nexport function addFormEvent(form: HTMLFormElement, action: () => void) {\n  form.addEventListener('submit', (e) => {\n    e.preventDefault();\n    action();\n  });\n}\n","export type Category = {\n  duplicate: boolean;\n  nbTurns: number;\n  nbColors: number;\n  nbPossibilities: number;\n};\n\nexport type Run = {\n  category: Category;\n  date: Date;\n  time: number; // time in second to complete the game\n};\n\n/**\n *\n * @param {Category} category the category of a run\n * @returns the string key representation of the category :\n *  \"duplicate-nbTurns-nbColros-nbPossibilities\" with the respective\n *  category value\n */\nexport function generateKey({\n  nbPossibilities,\n  nbColors,\n  nbTurns,\n  duplicate,\n}: Category): string {\n  return `${duplicate}-${nbTurns}-${nbColors}-${nbPossibilities}`;\n}\n\n/**\n * @description Save the record in the local storage with this configuration :\n *  - key : duplicate-nbTurns-nbColors-nbPossibilities\n *  - value : the number in seconds\n * @param {Run} record the new record\n */\nexport function setRecord({ category, time, date }: Run) {\n  localStorage.setItem(generateKey(category), JSON.stringify({ time, date }));\n}\n\n/**\n *\n * @param {Category} category the category of the records\n * @returns {number | null} Return the record of the category or null if no record has been set\n */\nexport function getRecord(category: Category): Run | null {\n  const key = generateKey(category);\n\n  const recordJson = localStorage.getItem(key);\n\n  if (!recordJson) {\n    return null;\n  }\n\n  const record = JSON.parse(recordJson);\n\n  return { time: record.time, date: new Date(record.date), category };\n}\n\n/**\n *\n * @param {Run} run The user run\n * @returns Compare the run pass in param to the actual record of the categort and return true\n * if the run pass in param is better. If no record is set, it return true too.\n */\nexport function isNewRecord(run: Run): boolean {\n  const previousRecord = getRecord(run.category);\n\n  if (!previousRecord) {\n    return true;\n  }\n\n  if (run.time < previousRecord.time) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {Run} run the user run\n * @returns {{isNew : boolean, record : Run}} return an object thats says if the run is a new record or not and return the actual record for the category\n */\nexport default function handleRun(run: Run): {\n  isNew: boolean;\n  record: Run;\n  previousRecord: Run | null;\n} {\n  const response: { isNew: boolean; record: Run; previousRecord: Run | null } =\n    {\n      isNew: true,\n      record: run,\n      previousRecord: null,\n    };\n\n  if (isNewRecord(run)) {\n    response.previousRecord = getRecord(run.category);\n    setRecord(run);\n  } else {\n    response.isNew = false;\n    response.record = getRecord(run.category) as Run;\n  }\n\n  return response;\n}\n","import {\n  getCurrentCombination,\n  getCombinationPlacement,\n  generateCombination,\n  getAvailableColors,\n} from './combination';\n\nimport {\n  addTargetListener,\n  removeTargetListener,\n  setDragListenerOnPieces,\n  addReducePopUpListener,\n  addFormEvent,\n} from './listeners';\n\nimport {\n  addNewGameLine,\n  addIndicators,\n  Indicators,\n  hideUnwantedColor,\n  getGameDomElements,\n  updateTooltip,\n  changeVerifyContent,\n  displayPreviousRecord,\n  displayNewRecord,\n} from './dom-manipulation';\n\nimport handleRun, { getRecord, Run } from './record';\n\nimport { getDateDifference } from './time';\n\nimport GameState from './game-state';\n\n// get the game container\nconst gameContainer = document.getElementById(\n  'game-container',\n) as HTMLDivElement;\n\n// Get all the pieces of the game\nconst bluePiece = document.getElementById('blue-piece') as HTMLDivElement;\nconst redPiece = document.getElementById('red-piece') as HTMLDivElement;\nconst greenPiece = document.getElementById('green-piece') as HTMLDivElement;\nconst yellowPiece = document.getElementById('yellow-piece') as HTMLDivElement;\nconst orangePiece = document.getElementById('orange-piece') as HTMLDivElement;\nconst blackPiece = document.getElementById('black-piece') as HTMLDivElement;\nconst whitePiece = document.getElementById('white-piece') as HTMLDivElement;\nconst marronPiece = document.getElementById('maroon-piece') as HTMLDivElement;\nconst pieces = [\n  bluePiece,\n  redPiece,\n  greenPiece,\n  yellowPiece,\n  orangePiece,\n  blackPiece,\n  whitePiece,\n  marronPiece,\n];\n\nsetDragListenerOnPieces(pieces);\n\n// All the color available in the game based on the pieces id available\nconst COLORS = pieces.map((piece) => piece.id.split('-')[0]);\n\n// Get all Popup\nconst parametersPopup = document.getElementById(\n  'parametersPopup',\n) as HTMLFormElement;\nconst winPopup = document.getElementById('win') as HTMLDivElement;\nconst losePopup = document.getElementById('lose') as HTMLDivElement;\n\naddFormEvent(parametersPopup, applyParameters);\n\n// The button of the game\nconst cancelParametersButton = document.getElementById(\n  'cancelParameters',\n) as HTMLButtonElement;\nconst verifyButton = document.getElementById('verify') as HTMLButtonElement;\nconst restartButton = document.getElementById('restart') as HTMLButtonElement;\nconst winRestartButton = document.getElementById(\n  'win-restart',\n) as HTMLButtonElement;\nconst loseRestartButton = document.getElementById(\n  'lose-restart',\n) as HTMLButtonElement;\nconst parametersButton = document.getElementById(\n  'parameters',\n) as HTMLButtonElement;\nconst reduceButtons = document.getElementsByClassName(\n  'reduce-popUp',\n) as HTMLCollectionOf<HTMLButtonElement>;\n\naddReducePopUpListener(reduceButtons);\n\n// The tooltip of the verify button\nconst verifyTooltip = document.getElementById('tooltip') as HTMLDivElement;\n\n// Parameters value from the DOM Popup\nconst duplicateCheckBox = document.getElementById(\n  'duplicateCheck',\n) as HTMLInputElement;\nconst nbColorsValue = document.getElementById(\n  'nbColorsValue',\n) as HTMLInputElement;\nconst nbTurnsValue = document.getElementById(\n  'nbTurnsValue',\n) as HTMLInputElement;\nconst nbPossibilitiesValue = document.getElementById(\n  'nbPossibilitiesValue',\n) as HTMLInputElement;\n\n// Current game round\n// min : 1 | max : nbTurns\nlet currentRound: number;\n\n// Game DOM variables\nlet currentTargets: NodeListOf<HTMLDivElement>;\nlet currentRedIndicatorsContainer: HTMLDivElement;\nlet currentWhiteIndicatorsContainer: HTMLDivElement;\n\nlet gameCombination: string[];\n\nlet gameState: GameState;\n\n// Game run date\nlet runStart: Date;\nlet runEnd: Date;\n\n// Game params\n\n/**\n * A boolean that indicates whether the combination can have\n * duplicate colors or not\n **/\nlet duplicate = duplicateCheckBox.checked;\n\n/**\n * The number of turns in the game\n */\nlet nbTurns = nbTurnsValue.valueAsNumber;\n\n/**\n * The number of colors available for the player\n */\nlet nbColors = nbColorsValue.valueAsNumber;\n\n/**\n * The number of colors in a line\n */\nlet nbPossibilities = nbPossibilitiesValue.valueAsNumber;\n\n/**\n * @description Reset all the HTML of the game container and start a new game\n * by generating a new combination and reset game DOM variables\n */\nfunction startNewGame() {\n  gameState = GameState.running;\n\n  currentRound = 1;\n  updateTooltip(verifyTooltip, currentRound, nbTurns);\n  const colorsAvailable = getAvailableColors(COLORS, nbColors);\n\n  hideUnwantedColor(COLORS, colorsAvailable);\n\n  gameCombination = generateCombination(\n    colorsAvailable,\n    nbPossibilities,\n    duplicate,\n  );\n\n  gameContainer.innerHTML = '';\n  addNewGameLine(currentRound, gameContainer, nbPossibilities);\n\n  const { targets, redIndicatorsContainer, whiteIndicatorsContainer } =\n    getGameDomElements(currentRound);\n\n  currentTargets = targets;\n  currentRedIndicatorsContainer = redIndicatorsContainer;\n  currentWhiteIndicatorsContainer = whiteIndicatorsContainer;\n  addTargetListener(currentTargets, COLORS);\n\n  changeVerifyContent(verifyButton, gameState);\n\n  runStart = new Date();\n}\n\n/**\n * @description Remove all the events of the previous line, create a new line with the current index,\n * update the game DOM variables and add eventListeners to them\n */\nfunction createNewRound() {\n  removeTargetListener(currentTargets);\n\n  currentRound++;\n\n  updateTooltip(verifyTooltip, currentRound, nbTurns);\n\n  addNewGameLine(currentRound, gameContainer, nbPossibilities);\n  const { targets, redIndicatorsContainer, whiteIndicatorsContainer } =\n    getGameDomElements(currentRound);\n\n  currentTargets = targets;\n  currentRedIndicatorsContainer = redIndicatorsContainer;\n  currentWhiteIndicatorsContainer = whiteIndicatorsContainer;\n  addTargetListener(currentTargets, COLORS);\n}\n\n/**\n * @description Add the nbRound value to the win popup and display it\n */\nfunction displayWinPopup() {\n  (\n    document.getElementById('nb-round') as HTMLParagraphElement\n  ).innerHTML = `Tu as trouvé la combinaison en ${currentRound} tours`;\n  winPopup.style.display = 'flex';\n}\n\n/**\n * @description Add the game combination to the lose popup and display it\n */\nfunction displaylosePopup() {\n  const solutionCombinaison = document.getElementById(\n    'solution-combination',\n  ) as HTMLDivElement;\n\n  // Reset previous solution\n  solutionCombinaison.innerHTML = '';\n\n  for (let i = 0; i < gameCombination.length; i++) {\n    const div = document.createElement('div');\n    div.classList.add('piece', gameCombination[i]);\n    solutionCombinaison.appendChild(div);\n  }\n  losePopup.style.display = 'flex';\n}\n\n/**\n * @description Update the tooltip and the verify content and display the corresponding end game popUp. It also\n * get the record of the caategory and display a message accroding to if the currentRun is a new record in the\n * category or not\n * @param {EndGameStatus} status The end game status, either win or lose\n */\nfunction handleEndGame() {\n  runEnd = new Date();\n\n  changeVerifyContent(verifyButton, gameState);\n\n  // We set currentRound+1 so that the tooltip display 0 round left\n  updateTooltip(verifyTooltip, currentRound + 1, nbTurns);\n\n  const currentRun: Run = {\n    category: {\n      nbTurns,\n      nbColors,\n      nbPossibilities,\n      duplicate,\n    },\n    time: getDateDifference(runStart, runEnd),\n    date: new Date(),\n  };\n\n  if (gameState === GameState.win) {\n    const p = document.querySelector('#win-record p') as HTMLParagraphElement;\n\n    const { isNew, record, previousRecord } = handleRun(currentRun);\n    if (isNew) {\n      displayNewRecord(p, record, previousRecord);\n    } else {\n      displayPreviousRecord(p, record, currentRun, gameState);\n    }\n\n    displayWinPopup();\n    return;\n  }\n\n  const p = document.querySelector('#lose-record p') as HTMLParagraphElement;\n\n  displayPreviousRecord(\n    p,\n    getRecord(currentRun.category),\n    currentRun,\n    gameState,\n  );\n\n  displaylosePopup();\n}\n\n/**\n * @description Verify the current combination. It can either:\n *  - display an error if the currentCombination is not complete\n *  - add indicators to the current line and add a new line\n *  - display win popup if the player find the gameCombination\n *  - display lose popup if the player failed to find the gameCombination\n */\nfunction verifyCurrentCombination() {\n  let currentCombination: string[];\n\n  try {\n    currentCombination = getCurrentCombination(currentTargets, COLORS);\n  } catch (err) {\n    return;\n  }\n\n  const { goodPlacement, wrongPlacement } = getCombinationPlacement(\n    currentCombination,\n    gameCombination,\n  );\n\n  // Add the indicators only if the game is not finish\n  if (gameState === GameState.running) {\n    addIndicators(Indicators.red, currentRedIndicatorsContainer, goodPlacement);\n\n    addIndicators(\n      Indicators.white,\n      currentWhiteIndicatorsContainer,\n      wrongPlacement,\n    );\n  }\n\n  if (goodPlacement === nbPossibilities) {\n    gameState = GameState.win;\n\n    handleEndGame();\n\n    return;\n  }\n\n  if (currentRound === nbTurns) {\n    gameState = GameState.lose;\n\n    handleEndGame();\n\n    return;\n  }\n\n  createNewRound();\n}\n\n/**\n * @description Set the params value and check if a new game can start with these params. If not,\n * it display an error\n */\nfunction applyParameters() {\n  duplicate = duplicateCheckBox.checked;\n  nbColors = nbColorsValue.valueAsNumber;\n  nbTurns = nbTurnsValue.valueAsNumber;\n  nbPossibilities = nbPossibilitiesValue.valueAsNumber;\n  if (duplicate === false && nbColors < nbPossibilities) {\n    alert(\n      `Attention, autorisez les doublons ou mettez un nombre de couleurs supérieur ou égal au nombre de possibilités par ligne`,\n    );\n    return;\n  }\n  parametersPopup.style.display = 'none';\n  startNewGame();\n}\n\nverifyButton.onclick = (e) => {\n  e.preventDefault();\n  if (gameState === GameState.running) {\n    verifyCurrentCombination();\n    return;\n  }\n\n  if (gameState === GameState.win) {\n    displayWinPopup();\n    return;\n  }\n\n  displaylosePopup();\n};\n\nrestartButton.onclick = startNewGame;\n\n// add cancel parameters event\ncancelParametersButton.onclick = () => {\n  parametersPopup.style.display = 'none';\n};\n\nparametersButton.onclick = () => {\n  parametersPopup.style.display = 'flex';\n};\n\nwinRestartButton.onclick = (e) => {\n  e.preventDefault();\n  winPopup.style.display = 'none';\n  startNewGame();\n};\n\nloseRestartButton.onclick = (e) => {\n  e.preventDefault();\n  losePopup.style.display = 'none';\n  startNewGame();\n};\n\nstartNewGame();\n"],"names":["getColorApparition","combination","color","filter","e","length","getDateDifference","runStart","runEnd","Error","getTime","convertMsToTime","duration","milliseconds","Math","floor","seconds","minutes","hours","convertTimeToString","time","result","GameState","Indicators","addNewGameLine","round","gameContainer","nbPossibilities","line","document","createElement","classList","add","id","redIndicatorContainer","whiteIndicatorContainer","targetContainer","i","target","targetPiece","appendChild","style","width","addIndicators","type","container","number","indicator","red","white","changePieceDisplay","display","getElementById","getGameDomElements","targets","querySelectorAll","redIndicatorsContainer","querySelector","whiteIndicatorsContainer","updateTooltip","tooltip","currentRound","nbTurns","span","roundLeft","innerHTML","changeVerifyContent","verifyButton","gameState","displayPreviousRecord","p","record","run","text","timeString","runDiff","date","toLocaleDateString","toLocaleTimeString","setPieceDragData","split","dataTransfer","setData","effectAllowed","setTargetDropEffect","preventDefault","dropEffect","setTargetBackgroundColor","colors","getData","currentTarget","remove","removeColorFromTarget","value","addTargetListener","addEventListener","removeTargetListener","removeEventListener","reduceButtonPopUp","getElementsByClassName","closest","generateKey","nbColors","duplicate","getRecord","category","key","recordJson","localStorage","getItem","JSON","parse","Date","pieces","window","forEach","piece","setDragListenerOnPieces","action","COLORS","map","parametersPopup","winPopup","losePopup","duplicateCheckBox","checked","nbColorsValue","valueAsNumber","nbTurnsValue","nbPossibilitiesValue","alert","startNewGame","cancelParametersButton","restartButton","winRestartButton","loseRestartButton","parametersButton","buttons","addReducePopUpListener","currentTargets","currentRedIndicatorsContainer","currentWhiteIndicatorsContainer","gameCombination","verifyTooltip","finalColors","colorsAvailable","sort","random","slice","getAvailableColors","includes","shuffleColors","Array","from","Set","generateCombination","displayWinPopup","displaylosePopup","solutionCombinaison","div","handleEndGame","response","currentRun","isNew","previousRecord","isNewRecord","setItem","stringify","newRecord","timeDiff","displayNewRecord","onclick","currentCombination","currentTargetPiece","className","push","setTimeout","getCurrentCombination","err","finalCombination","goodPlacement","wrongPlacement","index","getCombinationPlacement","createNewRound","verifyCurrentCombination"],"sourceRoot":""}